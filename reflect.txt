/*****************************************************************************
Milestone - 3
Full Name : Sergii Safronov
Student ID# : 132736224
Email : SSafronov@myseneca.ca
Section : RNB
Date : April 4, 2024

Authenticity Declaration :
I have done all the coding by myself and only copied the code
that my professor provided to complete my workshops and assignments.
*****************************************************************************/

I would like to write about std::deque. It is one of the most important parts of this project that I learned. 

There are three double-ended queues (contains): g_pending, g_completed, g_incomplete.
They are accessible from any part of the program. As the program runs, orders are added to the g_pending deque.
After that orders are moved through the workstations. If an order is successfully filled at a workstation, it will be moved to the g_completed deque.
If an order cannot be filled, it will be moved to the g_incomplete deque, indicating that it could not be completed. 
Why double-ended queues are used here? Because of their nature. They a similar to vectors but allow for efficient insertion and removal of elements from front and back.
They also automatically adjust their size. In the example, g_pending stores orders that are waiting to be processed on the assembly line.
When a new order is received, it is added to this deque:

 bool LineManager::run(std::ostream& os) {
*********
    if (!g_pending.empty()) {
        *m_firstStation += std::move(g_pending.front()); 
        g_pending.pop_front(); 
    }
**********
}

In this code snippet, g_pending.front() retrieves the first order from the deque, which is then moved to the first station of the assembly line: *m_firstStation += std::move(g_pending.front()).
After processing the order, g_pending.pop_front() removes it from the deque.
Another important part of the project is practice with lambdas.
In the LineManager constructor I created findStationByName to search for a workstation the collection of stations based on item name.
It uses the std::find_if algorithm to iterate through the collection and find the first workstation with matching name.
In case of successful search, a pointer to that workstation is returned, otherwise it returns nullptr. 

  auto findStationByName = [&](const std::string& name) -> Workstation* {
      auto it = std::find_if(stations.begin(), stations.end(),
                             [&](const Workstation* ws) { return ws->getItemName() == name; });
      return it != stations.end() ? *it : nullptr;
  };

Overall, there are many other useful examples, but these where the hardest ones. That is why I focused on them in this reflection.